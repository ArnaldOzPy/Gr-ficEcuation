<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador Cient√≠fico 3D v2.1 | BIG BOSS IA</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Source+Code+Pro:wght@300;600&display=swap" rel="stylesheet">
    <style>
        body { margin:0; background:#050510; color:white; font-family:'Source Code Pro', monospace; overflow:hidden; }
        #portada {
            position:fixed; top:0; left:0; width:100%; height:100vh; display:flex; flex-direction:column;
            justify-content:center; align-items:center; text-align:center;
            background:radial-gradient(circle at 20% 30%, rgba(0,150,255,0.15), transparent),
                       radial-gradient(circle at 80% 70%, rgba(255,0,150,0.15), transparent),
                       linear-gradient(180deg,#020210,#050520);
            z-index:1000; transition:opacity 1s ease;
        }
        .titulo {
            font-family:'Orbitron', sans-serif; font-size:60px; font-weight:700; letter-spacing:4px;
            background:linear-gradient(90deg,#00d4ff,#ff00cc); -webkit-background-clip:text;
            -webkit-text-fill-color:transparent; margin-bottom:20px; animation:glow 3s infinite alternate;
        }
        @keyframes glow { 0%{text-shadow:0 0 10px rgba(0,212,255,0.3);} 100%{text-shadow:0 0 20px rgba(255,0,204,0.5);} }
        .subtitulo { font-size:18px; color:#aaa; max-width:600px; line-height:1.6; }
        .ecuacion {
            margin-top:30px; font-size:28px; color:#00d4ff; font-family:'Orbitron', monospace;
            background:rgba(0,20,40,0.5); padding:10px 30px; border-radius:40px;
            border:1px solid #00d4ff33; box-shadow:0 0 20px #00d4ff22;
        }
        .boton {
            margin-top:40px; padding:15px 40px; font-size:18px; font-family:'Orbitron', sans-serif;
            background:linear-gradient(90deg,#0066ff,#00ccff); border:none; border-radius:8px;
            color:white; cursor:pointer; transition:0.3s; border:1px solid rgba(255,255,255,0.2);
            font-weight:600; letter-spacing:1px;
        }
        .boton:hover { transform:scale(1.1); box-shadow:0 0 20px rgba(0,150,255,0.6); background:linear-gradient(90deg,#0077ff,#00ddff); }
        .creditos-portada { position:absolute; bottom:20px; font-size:14px; color:#666; }
        #graficador-container { position:fixed; top:0; left:0; width:100%; height:100vh; opacity:0; visibility:hidden; transition:opacity 1s ease; background:#111122; }
        #graficador-container.visible { opacity:1; visibility:visible; }
        canvas { display:block; }
    </style>
</head>
<body>
    <div id="portada">
        <div class="titulo">SCIENTIFIC 3D EQUATION VISUALIZER v2.1</div>
        <div class="subtitulo">
            Motor avanzado de visualizaci√≥n matem√°tica con raymarching impl√≠cito.<br>
            Validado num√©ricamente para investigaci√≥n y docencia.<br>
            Superficies definidas por F(x,y,z)=0.
        </div>
        <div class="ecuacion">F(x,y,z) = 0</div>
        <button class="boton" onclick="iniciarVisualizador()">INICIAR VISUALIZADOR</button>
        <div class="creditos-portada">Desarrollado por BIG BOSS IA ¬∑ Paraguay ¬∑ 2026</div>
    </div>
    <div id="graficador-container"></div>

    <script>
        function iniciarVisualizador() {
            const portada = document.getElementById('portada');
            const contenedor = document.getElementById('graficador-container');
            portada.style.opacity = '0';
            setTimeout(() => {
                portada.style.display = 'none';
                contenedor.classList.add('visible');
            }, 1000);
            if (!window.graficadorIniciado) {
                window.graficadorIniciado = true;
                iniciarGraficador();
            }
        }

        function iniciarGraficador() {
            const container = document.getElementById('graficador-container');

            // ---- INTERFAZ DE USUARIO ----
            const infoDiv = document.createElement('div');
            infoDiv.id = 'info';
            infoDiv.innerHTML = `
                <h2>‚ö° Graficador Cient√≠fico v2.1</h2>
                <p style="margin:0 0 5px; color:#ccc; font-size:14px;">F(x, y, z) = 0</p>
                <input type="text" id="ecuacion-input" placeholder="Ej: x*x + y*y + z*z - 4.0" value="x*x + y*y + z*z - 4.0">
                
                <div style="margin:10px 0;">
                    <label for="escala" style="color:#ccc; font-size:12px;">Escala global:</label>
                    <input type="range" id="escala" min="0.2" max="3.0" step="0.1" value="1.0" style="width:100%;">
                    <span id="escala-valor" style="color:#00a8ff; font-size:12px; float:right;">1.0</span>
                </div>

                <div id="ejemplos" style="max-height:200px; overflow-y:auto; padding-right:5px;">
                    <strong>üìå Ejemplos cient√≠ficos:</strong><br>
                    <span class="ejemplo-btn" onclick="cargarEjemplo('x*x + y*y + z*z - 4.0')">Esfera</span>
                    <span class="ejemplo-btn" onclick="cargarEjemplo('(sqrt(x*x+y*y)-2.0)*(sqrt(x*x+y*y)-2.0) + z*z - 0.5')">Toro</span>
                    <span class="ejemplo-btn" onclick="cargarEjemplo('x*x + y*y - z')">Paraboloide</span>
                    <span class="ejemplo-btn" onclick="cargarEjemplo('sin(x*y*z)')">Campo seno</span>
                    <span class="ejemplo-btn" onclick="cargarEjemplo('exp(-x*x-y*y-z*z) - 0.3')">Gaussiana</span>
                    <span class="ejemplo-btn" onclick="cargarEjemplo('x*x - y*y - z')">Silla</span>
                    <span class="ejemplo-btn" onclick="cargarEjemplo('x*x + 2.0*y*y - 3.0*z*z - 1.0')">Hiperboloide</span>
                    <span class="ejemplo-btn" onclick="cargarEjemplo('x*y*z - 0.2')">Superficie c√∫bica</span>
                </div>
                <button onclick="actualizarEcuacion()">üîÑ Renderizar</button>
                <div id="error"></div>
                <p style="margin:15px 0 0; font-size:12px; color:#888;">
                    Funciones GLSL: sin, cos, tan, asin, acos, atan, sinh, cosh, tanh, exp, log, abs, sqrt, pow<br>
                    Notaci√≥n: usar x, y, z. Ajusta la escala si la superficie no se ve.
                </p>
            `;
            container.appendChild(infoDiv);

            const controlesDiv = document.createElement('div');
            controlesDiv.id = 'controles';
            controlesDiv.innerHTML = 'üñ±Ô∏è Rotar: arrastrar | Zoom: rueda | Pan: Shift+arrastrar';
            container.appendChild(controlesDiv);

            const creditosDiv = document.createElement('div');
            creditosDiv.id = 'creditos';
            creditosDiv.innerHTML = 'Basado en <a href="https://informaticabigbosspy.blogspot.com" target="_blank">informaticabigbosspy.blogspot.com</a>';
            container.appendChild(creditosDiv);

            // Estilos del panel
            const style = document.createElement('style');
            style.textContent = `
                #info {
                    position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.85); color: white;
                    padding: 20px; border-radius: 10px; z-index: 100; box-shadow: 0 4px 20px rgba(0,0,0,0.5);
                    border-left: 4px solid #00a8ff; max-width: 360px; backdrop-filter: blur(8px);
                    pointer-events: all; font-family: 'Source Code Pro', monospace; max-height: 80vh; overflow-y: auto;
                }
                #info h2 { margin-top:0; color:#00a8ff; border-bottom:1px solid #333; padding-bottom:8px; }
                #ecuacion-input {
                    width:100%; padding:12px; margin:12px 0; background:rgba(20,20,30,0.9);
                    border:1px solid #444; color:#fff; border-radius:6px; font-family:'Courier New', monospace;
                    font-size:15px; box-sizing:border-box;
                }
                #ecuacion-input:focus { outline:none; border-color:#00a8ff; box-shadow:0 0 0 2px rgba(0,168,255,0.2); }
                button {
                    background:#00a8ff; color:white; border:none; padding:12px 20px; border-radius:6px;
                    cursor:pointer; font-weight:600; width:100%; font-size:16px; transition:0.2s;
                }
                button:hover { background:#0090e0; }
                #error {
                    color:#ff6b6b; margin-top:12px; font-size:14px; display:none;
                    background:rgba(255,0,0,0.1); padding:8px; border-radius:4px; border-left:3px solid #ff6b6b;
                }
                #ejemplos { margin-top:18px; font-size:13px; color:#aaa; }
                .ejemplo-btn {
                    background:#2a2a3a; color:#ddd; border:1px solid #444; padding:6px 12px;
                    border-radius:20px; cursor:pointer; font-size:12px; margin:4px 4px 0 0;
                    display:inline-block; transition:0.2s;
                }
                .ejemplo-btn:hover { background:#3a4a6a; border-color:#00a8ff; color:white; }
                #controles {
                    position:absolute; bottom:20px; left:20px; color:rgba(255,255,255,0.7); font-size:13px;
                    z-index:100; background:rgba(0,0,0,0.5); padding:8px 16px; border-radius:30px;
                    backdrop-filter:blur(4px); pointer-events:none;
                }
                #creditos {
                    position:absolute; bottom:20px; right:20px; color:rgba(255,255,255,0.5); font-size:13px;
                    z-index:100; background:rgba(0,0,0,0.5); padding:8px 16px; border-radius:30px;
                    backdrop-filter:blur(4px);
                }
                #creditos a { color:#00a8ff; text-decoration:none; font-weight:500; }
                #creditos a:hover { text-decoration:underline; }
            `;
            document.head.appendChild(style);

            // ---- IMPORTACI√ìN DE THREE.JS ----
            const scriptMap = document.createElement('script');
            scriptMap.type = 'importmap';
            scriptMap.textContent = JSON.stringify({
                imports: {
                    "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
                }
            });
            document.head.appendChild(scriptMap);

            // ---- C√ìDIGO PRINCIPAL DEL GRAFICADOR (M√ìDULO) ----
            const scriptGraficador = document.createElement('script');
            scriptGraficador.type = 'module';
            scriptGraficador.textContent = `
                import * as THREE from 'three';
                import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
                import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

                // --- Configuraci√≥n de escena ---
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a0a20);

                const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(6, 5, 10); // Posici√≥n ligeramente m√°s lejana
                camera.lookAt(0, 0, 0);

                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('graficador-container').appendChild(renderer.domElement);

                const labelRenderer = new CSS2DRenderer();
                labelRenderer.setSize(window.innerWidth, window.innerHeight);
                labelRenderer.domElement.style.position = 'absolute';
                labelRenderer.domElement.style.top = '0px';
                labelRenderer.domElement.style.left = '0px';
                labelRenderer.domElement.style.pointerEvents = 'none';
                document.getElementById('graficador-container').appendChild(labelRenderer.domElement);

                // --- Controles ---
                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.screenSpacePanning = true;
                controls.maxPolarAngle = Math.PI / 2;
                controls.rotateSpeed = 0.8;
                controls.zoomSpeed = 1.2;

                // --- Luces ---
                const ambientLight = new THREE.AmbientLight(0x404060);
                scene.add(ambientLight);

                // --- Fondo estelar ---
                const starsGeometry = new THREE.BufferGeometry();
                const starsCount = 2000;
                const starsPositions = new Float32Array(starsCount * 3);
                for (let i = 0; i < starsCount * 3; i += 3) {
                    starsPositions[i] = (Math.random() - 0.5) * 200;
                    starsPositions[i+1] = (Math.random() - 0.5) * 200;
                    starsPositions[i+2] = (Math.random() - 0.5) * 200;
                }
                starsGeometry.setAttribute('position', new THREE.BufferAttribute(starsPositions, 3));
                const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true });
                const stars = new THREE.Points(starsGeometry, starsMaterial);
                scene.add(stars);

                // --- Ejes con etiquetas ---
                function crearEjes() {
                    const length = 5.5;
                    const headLength = 0.3;
                    const headWidth = 0.2;
                    
                    const ejeX = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), length, 0xff3333, headLength, headWidth);
                    const ejeY = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), length, 0x33ff33, headLength, headWidth);
                    const ejeZ = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), length, 0x3388ff, headLength, headWidth);
                    scene.add(ejeX);
                    scene.add(ejeY);
                    scene.add(ejeZ);

                    const crearEtiqueta = (texto, color, pos) => {
                        const div = document.createElement('div');
                        div.textContent = texto;
                        div.style.color = color;
                        div.style.fontSize = '20px';
                        div.style.fontWeight = 'bold';
                        div.style.textShadow = '1px 1px 3px #000';
                        const label = new CSS2DObject(div);
                        label.position.copy(pos);
                        return label;
                    };

                    scene.add(crearEtiqueta('X', '#ff8888', new THREE.Vector3(length + 0.6, 0, 0)));
                    scene.add(crearEtiqueta('Y', '#88ff88', new THREE.Vector3(0, length + 0.6, 0)));
                    scene.add(crearEtiqueta('Z', '#8888ff', new THREE.Vector3(0, 0, length + 0.6)));
                }
                crearEjes();

                // --- Par√°metros del raymarching ---
                const boxSize = 8.0; // Aumentado para dar m√°s margen
                const geometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);

                // Vertex shader (sin cambios)
                const vertexShader = \`
                    varying vec3 vPosition;
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                \`;

                // Fragment shader MEJORADO con paso m√°s fino y m√°s pasos
                const fragmentShaderBase = \`
                    precision highp float;
                    
                    varying vec3 vPosition;
                    varying vec2 vUv;
                    
                    uniform vec3 cameraPos;
                    uniform float time;
                    uniform mat4 modelMatrix;
                    uniform float escalaGlobal; // Nuevo uniform para escala
                    
                    const float BOX_SIZE = \${boxSize.toFixed(1)};
                    const float EPS = 0.0005;
                    const int MAX_STEPS = 600;
                    const float MAX_DIST = 25.0;
                    
                    float scene(vec3 p) {
                        // Aplicar escala global
                        vec3 q = p / escalaGlobal;
                        float x = q.x;
                        float y = q.y;
                        float z = q.z;
                        float val = {{ECUACION}};
                        return val;
                    }
                    
                    vec3 calcNormal(vec3 p) {
                        float h = 0.001;
                        vec2 e = vec2(1.0, -1.0) * h;
                        return normalize(
                            e.xyy * scene(p + e.xyy) +
                            e.yxy * scene(p + e.yxy) +
                            e.yyx * scene(p + e.yyx) +
                            e.xxx * scene(p + e.xxx)
                        );
                    }
                    
                    vec3 shade(vec3 p, vec3 dir) {
                        vec3 normal = calcNormal(p);
                        vec3 lightDir = normalize(vec3(1.0, 2.0, 1.0));
                        vec3 viewDir = -dir;
                        
                        float diff = max(dot(normal, lightDir), 0.0);
                        float spec = 0.0;
                        if (diff > 0.0) {
                            vec3 halfVec = normalize(lightDir + viewDir);
                            spec = pow(max(dot(normal, halfVec), 0.0), 32.0);
                        }
                        
                        vec3 colorBase = 0.5 + 0.5 * normal;
                        vec3 ambient = 0.1 * colorBase;
                        vec3 diffuse = diff * colorBase;
                        vec3 specular = spec * vec3(1.0);
                        
                        return ambient + diffuse + specular;
                    }
                    
                    // Intersecci√≥n rayo-caja (algoritmo de slabs)
                    bool intersectBox(vec3 ro, vec3 rd, vec3 boxMin, vec3 boxMax, out float tmin, out float tmax) {
                        vec3 invR = 1.0 / rd;
                        vec3 t1 = (boxMin - ro) * invR;
                        vec3 t2 = (boxMax - ro) * invR;
                        vec3 tsmin = min(t1, t2);
                        vec3 tsmax = max(t1, t2);
                        tmin = max(tsmin.x, max(tsmin.y, tsmin.z));
                        tmax = min(tsmax.x, min(tsmax.y, tsmax.z));
                        return tmin <= tmax && tmax >= 0.0;
                    }
                    
                    bool raymarch(vec3 ro, vec3 rd, out vec3 hitPos, out vec3 hitNormal) {
                        // Bounding box del cubo
                        vec3 boxMin = vec3(-BOX_SIZE * 0.5);
                        vec3 boxMax = vec3( BOX_SIZE * 0.5);
                        
                        float tmin, tmax;
                        if (!intersectBox(ro, rd, boxMin, boxMax, tmin, tmax)) {
                            return false;
                        }
                        
                        float t = max(tmin, 0.0);
                        float endT = min(tmax, MAX_DIST);
                        
                        for (int i = 0; i < MAX_STEPS; i++) {
                            vec3 p = ro + rd * t;
                            float val = scene(p);
                            
                            if (abs(val) < EPS) {
                                hitPos = p;
                                hitNormal = calcNormal(p);
                                return true;
                            }
                            
                            // Paso adaptativo m√°s conservador (0.75)
                            t += max(0.0003, abs(val) * 0.75);
                            if (t > endT) break;
                        }
                        return false;
                    }
                    
                    void main() {
                        vec3 worldPos = (modelMatrix * vec4(vPosition, 1.0)).xyz;
                        
                        vec3 ro = cameraPos;
                        vec3 rd = normalize(worldPos - cameraPos);
                        
                        vec3 hitPos, hitNormal;
                        if (raymarch(ro, rd, hitPos, hitNormal)) {
                            vec3 color = shade(hitPos, rd);
                            gl_FragColor = vec4(color, 1.0);
                        } else {
                            discard;
                        }
                    }
                \`;

                // Material inicial
                let material = new THREE.ShaderMaterial({
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShaderBase.replace('{{ECUACION}}', 'x*x + y*y + z*z - 4.0'),
                    uniforms: {
                        cameraPos: { value: camera.position.clone() },
                        time: { value: 0 },
                        modelMatrix: { value: new THREE.Matrix4() },
                        escalaGlobal: { value: 1.0 }
                    },
                    side: THREE.DoubleSide,
                    transparent: true
                });

                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);

                // --- Elementos de la interfaz de escala ---
                const escalaInput = document.getElementById('escala');
                const escalaValor = document.getElementById('escala-valor');
                
                escalaInput.addEventListener('input', () => {
                    const val = parseFloat(escalaInput.value);
                    escalaValor.textContent = val.toFixed(1);
                    if (material) {
                        material.uniforms.escalaGlobal.value = val;
                    }
                });

                // --- Funciones de actualizaci√≥n ---
                window.actualizarEcuacion = function() {
                    const ecuacionRaw = document.getElementById('ecuacion-input').value;
                    
                    let ecuacionGLSL = ecuacionRaw
                        .replace(/Math\\.sin/g, 'sin')
                        .replace(/Math\\.cos/g, 'cos')
                        .replace(/Math\\.tan/g, 'tan')
                        .replace(/Math\\.asin/g, 'asin')
                        .replace(/Math\\.acos/g, 'acos')
                        .replace(/Math\\.atan/g, 'atan')
                        .replace(/Math\\.sinh/g, 'sinh')
                        .replace(/Math\\.cosh/g, 'cosh')
                        .replace(/Math\\.tanh/g, 'tanh')
                        .replace(/Math\\.exp/g, 'exp')
                        .replace(/Math\\.log/g, 'log')
                        .replace(/Math\\.abs/g, 'abs')
                        .replace(/Math\\.sqrt/g, 'sqrt')
                        .replace(/Math\\.pow\\(/g, 'pow(');
                    
                    ecuacionGLSL = ecuacionGLSL.replace(/(\\d+)(?!\\w)/g, '$1.0');
                    
                    try {
                        const nuevoFragmentShader = fragmentShaderBase.replace('{{ECUACION}}', ecuacionGLSL);
                        
                        material.dispose();
                        material = new THREE.ShaderMaterial({
                            vertexShader: vertexShader,
                            fragmentShader: nuevoFragmentShader,
                            uniforms: {
                                cameraPos: { value: camera.position.clone() },
                                time: { value: 0 },
                                modelMatrix: { value: mesh.matrixWorld },
                                escalaGlobal: { value: parseFloat(escalaInput.value) }
                            },
                            side: THREE.DoubleSide,
                            transparent: true
                        });
                        
                        mesh.material = material;
                        document.getElementById('error').style.display = 'none';
                    } catch (e) {
                        document.getElementById('error').style.display = 'block';
                        document.getElementById('error').textContent = 'Error: ' + e.message;
                    }
                };

                window.cargarEjemplo = function(ejemplo) {
                    document.getElementById('ecuacion-input').value = ejemplo;
                    actualizarEcuacion();
                };

                // --- Animaci√≥n ---
                function animate() {
                    requestAnimationFrame(animate);
                    
                    if (material) {
                        material.uniforms.cameraPos.value.copy(camera.position);
                        material.uniforms.time.value += 0.01;
                        material.uniforms.modelMatrix.value.copy(mesh.matrixWorld);
                    }
                    
                    controls.update();
                    renderer.render(scene, camera);
                    labelRenderer.render(scene, camera);
                }
                animate();

                // --- Resize ---
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    labelRenderer.setSize(window.innerWidth, window.innerHeight);
                });

                // Inicializar
                setTimeout(() => actualizarEcuacion(), 100);
            `;
            container.appendChild(scriptGraficador);
        }
    </script>
</body>
</html>
